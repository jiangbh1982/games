<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>贪吃蛇 Snake</title>
  <style>
    :root{
      --bg:#0f172a;       /* slate-900 */
      --panel:#111827;    /* gray-900 */
      --muted:#94a3b8;    /* slate-400 */
      --accent:#22c55e;   /* green-500 */
      --accent2:#ef4444;  /* red-500 */
      --grid:#1f2937;     /* gray-800 */
    }
    *{box-sizing:border-box}
    body{margin:0;background:linear-gradient(180deg,#0b1224, #0f172a 30%, #0b1224);
         color:white;font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,Apple SD Gothic Neo,Arial}
    .wrap{min-height:100svh;display:flex;flex-direction:column;}
    header{display:flex;align-items:center;justify-content:center;gap:16px;padding:16px 12px}
    .title{font-weight:700;letter-spacing:0.5px}
    .panel{background:rgba(17,24,39,.7);backdrop-filter: blur(8px);border:1px solid #1f2937;border-radius:16px;}
    .hud{display:flex;align-items:center;gap:12px;padding:10px 12px}
    .badge{padding:6px 10px;border-radius:9999px;background:#111827;border:1px solid #1f2937;color:#e5e7eb;font-weight:600}
    .btn{appearance:none;border:1px solid #1f2937;background:#0b1325;color:#e5e7eb;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer}
    .btn:hover{filter:brightness(1.1)}
    .grid{display:grid;grid-template-columns:1fr auto 1fr;gap:12px;align-items:center;margin:0 auto;max-width:980px;width:100%;padding:0 12px}
    .canvas-wrap{display:flex;justify-content:center}
    canvas{background:radial-gradient(1200px 800px at 50% 40%, #0d1b2a 10%, #0b1325 40%, #0a1222 70%);
           border-radius:24px;border:1px solid #1f2937;box-shadow:0 10px 40px rgba(0,0,0,.35);image-rendering:pixelated}
    footer{color:var(--muted);font-size:12px;text-align:center;padding:12px 0 24px}

    /* Touch controls */
    .touch{display:grid;grid-template-columns:64px 64px 64px;grid-template-rows:64px 64px 64px;gap:10px;justify-content:center;margin:14px auto}
    .touch .sp{visibility:hidden}
    .dpad-btn{border:1px solid #1f2937;background:#0b1325;color:#e5e7eb;border-radius:16px;display:flex;align-items:center;justify-content:center;font-weight:700;font-size:18px;user-select:none}
    .dpad-btn:active{transform:translateY(1px)}

    @media (max-width: 640px){
      .grid{grid-template-columns:1fr}
      .canvas-wrap{order:2}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1 class="title">🐍 贪吃蛇 Snake</h1>
    </header>

    <div class="grid">
      <div class="panel hud">
        <span class="badge">分数 <span id="score">0</span></span>
        <span class="badge">最高 <span id="best">0</span></span>
      </div>

      <div class="canvas-wrap">
        <canvas id="game" width="560" height="560" aria-label="贪吃蛇游戏画布" role="img"></canvas>
      </div>

      <div class="panel hud" style="justify-content:flex-end;gap:8px">
        <button class="btn" id="btnStart">开始/暂停</button>
        <button class="btn" id="btnRestart">重新开始</button>
        <select class="btn" id="speed">
          <option value="8">速度：慢</option>
          <option value="12" selected>速度：中</option>
          <option value="18">速度：快</option>
          <option value="24">速度：超快</option>
        </select>
        <label class="btn" style="display:flex;gap:8px;align-items:center">
          <input id="wrapMode" type="checkbox" /> 穿墙
        </label>
      </div>
    </div>

    <div class="touch" id="touch">
      <div class="sp"></div>
      <button class="dpad-btn" data-dir="up">▲</button>
      <div class="sp"></div>
      <button class="dpad-btn" data-dir="left">◀</button>
      <button class="dpad-btn" data-dir="down">▼</button>
      <button class="dpad-btn" data-dir="right">▶</button>
      <div class="sp"></div>
      <div class="sp"></div>
      <div class="sp"></div>
    </div>

    <footer>按键：W/A/S/D 或 ↑/←/↓/→；空格键开始/暂停；R 重开。</footer>
  </div>

  <script>
    // ===== Basic setup =====
    const cvs = document.getElementById('game');
    const ctx = cvs.getContext('2d');

    // Responsive canvas: fit to smaller side but keep 28x28 grid
    function fitCanvas(){
      const size = Math.min(560, Math.floor(Math.min(window.innerWidth-24, 560)));
      cvs.width = size; cvs.height = size; cell = Math.floor(size / GRID);
    }

    const GRID = 28; // 28x28 grid
    let cell = Math.floor(cvs.width / GRID);

    // Game state
    let snake, dir, nextDir, food, score, best, running, wrapWalls, speed, stepPerSec;
    let acc = 0, lastTs = 0; // fixed timestep accumulator

    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const wrapEl = document.getElementById('wrapMode');
    const speedSel = document.getElementById('speed');

    function init(){
      snake = [ {x:13,y:14}, {x:12,y:14}, {x:11,y:14} ];
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      score = 0; scoreEl.textContent = score;
      best = Number(localStorage.getItem('snake_best')||0);
      bestEl.textContent = best;
      wrapWalls = localStorage.getItem('snake_wrap')==='1';
      wrapEl.checked = wrapWalls;
      stepPerSec = Number(localStorage.getItem('snake_speed')||12);
      [...speedSel.options].forEach(o=>{ if(Number(o.value)===stepPerSec){o.selected=true} });
      placeFood();
      running = false;
      acc = 0; lastTs = 0;
      draw(true);
    }

    function placeFood(){
      while(true){
        const fx = Math.floor(Math.random()*GRID);
        const fy = Math.floor(Math.random()*GRID);
        if(!snake.some(s=>s.x===fx && s.y===fy)){ food = {x:fx,y:fy}; break; }
      }
    }

    function setDir(nx,ny){
      // prevent reversing on itself
      if(nx === -dir.x && ny === -dir.y) return;
      nextDir = {x:nx,y:ny};
    }

    // ===== Input =====
    window.addEventListener('keydown', e=>{
      if(e.code==='ArrowUp' || e.code==='KeyW') setDir(0,-1);
      else if(e.code==='ArrowDown' || e.code==='KeyS') setDir(0,1);
      else if(e.code==='ArrowLeft' || e.code==='KeyA') setDir(-1,0);
      else if(e.code==='ArrowRight' || e.code==='KeyD') setDir(1,0);
      else if(e.code==='Space'){ toggle(); }
      else if(e.code==='KeyR'){ restart(); }
    });

    document.getElementById('btnStart').onclick = toggle;
    document.getElementById('btnRestart').onclick = restart;
    wrapEl.onchange = ()=>{
      wrapWalls = wrapEl.checked; localStorage.setItem('snake_wrap', wrapWalls? '1':'0');
      draw(true);
    };
    speedSel.onchange = ()=>{
      stepPerSec = Number(speedSel.value);
      localStorage.setItem('snake_speed', String(stepPerSec));
    };

    // Touch controls
    document.getElementById('touch').addEventListener('click', (e)=>{
      const b = e.target.closest('[data-dir]');
      if(!b) return;
      const d = b.getAttribute('data-dir');
      if(d==='up') setDir(0,-1);
      if(d==='down') setDir(0,1);
      if(d==='left') setDir(-1,0);
      if(d==='right') setDir(1,0);
    })

    // ===== Game loop =====
    function toggle(){ running = !running; if(running) requestAnimationFrame(loop); }
    function restart(){ init(); running = true; requestAnimationFrame(loop); }

    function loop(ts){
      if(!running) return;
      if(!lastTs) lastTs = ts;
      const dt = (ts - lastTs) / 1000; // seconds
      lastTs = ts;
      acc += dt;
      const step = 1 / stepPerSec;
      while(acc >= step){
        update();
        acc -= step;
      }
      draw();
      requestAnimationFrame(loop);
    }

    function update(){
      dir = nextDir; // commit direction once per step
      const head = {x: snake[0].x + dir.x, y: snake[0].y + dir.y};

      // walls or wrap
      if(wrapWalls){
        head.x = (head.x + GRID) % GRID;
        head.y = (head.y + GRID) % GRID;
      } else {
        if(head.x < 0 || head.y < 0 || head.x >= GRID || head.y >= GRID){
          return gameOver();
        }
      }

      // self-collision
      if(snake.some((s,i)=> i>0 && s.x===head.x && s.y===head.y)){
        return gameOver();
      }

      snake.unshift(head);

      if(head.x===food.x && head.y===food.y){
        score += 10; scoreEl.textContent = score;
        if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('snake_best', String(best)); }
        placeFood();
      } else {
        snake.pop(); // move forward
      }
    }

    function draw(showGrid=false){
      // background
      ctx.clearRect(0,0,cvs.width,cvs.height);

      // grid (optional subtle)
      if(showGrid){
        ctx.save();
        ctx.strokeStyle = '#142137';
        ctx.lineWidth = 1;
        for(let i=1;i<GRID;i++){
          const p = i*cell + 0.5; // crisp lines
          ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,cvs.height); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(cvs.width,p); ctx.stroke();
        }
        ctx.restore();
      }

      // draw food (pulsing)
      const t = performance.now()/1000;
      const pulse = 0.15*Math.sin(t*6);
      roundedRect(food.x*cell+2, food.y*cell+2, cell-4, cell-4, 6);
      ctx.fillStyle = `hsl(${(t*120)%360}, 90%, ${55+pulse*10}%)`;
      ctx.fill();

      // draw snake
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const r = i===0 ? 8 : 6;
        roundedRect(s.x*cell+1.5, s.y*cell+1.5, cell-3, cell-3, r);
        ctx.fillStyle = i===0 ? '#22c55e' : '#16a34a';
        ctx.fill();
        if(i===0){ // tiny eye
          ctx.fillStyle = '#052e16';
          ctx.beginPath();
          ctx.arc(s.x*cell + cell*0.65, s.y*cell + cell*0.35, Math.max(1.5, cell*0.06), 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function roundedRect(x,y,w,h,r){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
    }

    function gameOver(){
      running = false;
      // darken
      ctx.fillStyle = 'rgba(0,0,0,.55)';
      ctx.fillRect(0,0,cvs.width,cvs.height);
      // text
      ctx.fillStyle = '#e5e7eb';
      ctx.font = `700 ${Math.floor(cvs.width*0.08)}px system-ui, -apple-system, Segoe UI`;
      ctx.textAlign = 'center';
      ctx.fillText('游戏结束', cvs.width/2, cvs.height/2 - 10);
      ctx.fillStyle = '#94a3b8';
      ctx.font = `500 ${Math.floor(cvs.width*0.04)}px system-ui, -apple-system, Segoe UI`;
      ctx.fillText('按 R 重新开始，空格继续', cvs.width/2, cvs.height/2 + 28);
    }

    window.addEventListener('resize', ()=>{ fitCanvas(); draw(true); });

    fitCanvas();
    init();
  </script>
</body>
</html>
